% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_bls_data.R
\name{get_bls_data}
\alias{get_bls_data}
\title{Fetch a TSV from the BLS flat file database over HTTP with an email User-Agent and parse it}
\usage{
get_bls_data(bls_url, email)
}
\arguments{
\item{bls_url}{A string scalar BLS URL (e.g., "https://download.bls.gov/pub/time.series/jt/jt.data.1.AllItems").}

\item{email}{A string scalar email address to include in the User-Agent header.}
}
\value{
A tibble parsed from the TSV response body.
}
\description{
Validates \code{bls_url} and \code{email} as string scalars, verifies the email format,
sends a GET request using \strong{httr2} with the email in the User-Agent header
and a request timeout, and on a successful response with \code{Content-Type: text/plain}
or \code{text/tab-separated-values} and a non-empty body, parses the payload as TSV
via \strong{readr} and returns a tibble.
}
\details{
\itemize{
\item Email validation uses a practical regex rather than full RFC 5322.
\item HTTP errors (non-2xx) raise an error with status, reason, URL, response headers,
and a short body snippet (best-effort).
\item If the response is successful but not \code{text/plain} or \code{text/tab-separated-values},
or the body is empty, an error is raised (with headers included).
}
}
\examples{
\dontrun{
df <- get_bls_data(
  bls_url = "https://download.bls.gov/pub/time.series/jt/jt.data.1.AllItems",
  email   = "you@example.com"
)
}

}
